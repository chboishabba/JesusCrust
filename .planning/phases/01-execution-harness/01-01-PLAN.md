---
phase: 01-execution-harness
type: execute
domain: core-runtime
---

<objective>
Phase 1 Objective: Implement a standalone JavaCrust execution harness validating transactional ticks, deferred DOM effects, and microtask coalescing.

Purpose: Prove the scheduling semantics before any browser or WASM integration.
Output: A QuickJS-powered harness, fake DOM, effect log, and deterministic replay tests.
</objective>

<execution_context>
~/.codex/skills/get-shit-done/workflows/execute-phase.md
~/.codex/skills/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-execution-harness/DISCOVERY.md

Phase 1 Scope
In-Scope:
- QuickJS embedding
- Fake DOM
- Effect log + commit
- Rollback on forbidden ops
- Determinism

Out-of-Scope:
- Browser integration
- Servo
- Performance benchmarks
- Drop-in acceleration
- Workers / SharedArrayBuffer

Deliverables (Day mapping):
- Day 1: Harness scaffold + QuickJS fixture runner + fake DOM interfaces
- Day 2: Effect log + commit/rollback semantics + forbidden op handling
- Day 3: Microtask coalescing + deterministic replay tests

Exit Criteria:
- One macrotask → one commit
- Microtasks coalesced into that commit
- Rollback leaves committed state untouched
- Deterministic replay produces identical effect logs

Risks & Mitigations:
- QuickJS integration risk → keep host API tiny and well-scoped
- Semantics ambiguity → spec beats code, write fixture-driven tests
- Scope creep → enforce forbidden ops list early
</context>

<tasks>

<task type="auto">
  <name>Task 1 (Day 1): Scaffold harness + QuickJS fixture runner</name>
  <files>Cargo.toml, crates/harness/Cargo.toml, crates/harness/src/lib.rs, crates/harness/src/runner.rs, crates/harness/src/fixture.rs, tests/js/README.md</files>
  <action>Create a Rust workspace with a `harness` crate that embeds QuickJS via `rquickjs`. Implement a minimal runner that loads JS fixtures from `tests/js/` and exposes a tiny host API for registering fake DOM effects. Keep the host API intentionally small (register effect, enqueue microtask, begin/commit/rollback). Avoid adding any browser bindings or JS DOM helpers.</action>
  <verify>`cargo check -p harness` succeeds</verify>
  <done>Workspace builds, fixtures can be loaded and executed, and host API surface is documented in `tests/js/README.md`</done>
</task>

<task type="auto">
  <name>Task 2 (Day 2): Implement fake DOM + effect log with commit/rollback</name>
  <files>crates/harness/src/fake_dom.rs, crates/harness/src/effect_log.rs, crates/harness/src/transaction.rs, crates/harness/tests/harness_effects.rs, tests/js/forbidden_ops.js</files>
  <action>Implement a fake DOM that records effect intents into an effect log. Add transactional boundaries so effects are buffered until commit and discarded on rollback when forbidden operations are detected. Define an explicit forbidden ops list and make rollback deterministic (no partial commits). Add a Rust test that executes `tests/js/forbidden_ops.js` and asserts the committed state remains unchanged after rollback.</action>
  <verify>`cargo test -p harness` passes</verify>
  <done>Effect log records deterministic ordering, commit applies all buffered effects, and rollback leaves committed state unchanged</done>
</task>

<task type="auto">
  <name>Task 3 (Day 3): Enforce microtask coalescing + deterministic replay</name>
  <files>crates/harness/src/runner.rs, crates/harness/src/replay.rs, crates/harness/tests/harness_microtasks.rs, tests/js/microtasks.js, tests/js/transactional_ticks.js</files>
  <action>Implement a macrotask tick that runs JS, collects microtasks, and commits exactly once per tick. Ensure microtasks coalesce into that commit rather than producing additional commits. Add a deterministic replay mode that replays the effect log and asserts identical ordering and payloads. Write fixture-driven tests for `microtasks.js` and `transactional_ticks.js` that assert one-commit-per-macrotask and identical replay output.</action>
  <verify>`cargo test -p harness` passes (run twice to confirm deterministic ordering)</verify>
  <done>Microtasks are coalesced into a single commit per macrotask and replay output is identical across runs</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `cargo test -p harness` passes
- [ ] Tests cover one macrotask → one commit, microtask coalescing, and rollback semantics
- [ ] Deterministic replay yields identical effect logs across runs
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- One macrotask results in exactly one commit
- Microtasks are coalesced into that commit
- Rollback preserves last committed state
- Deterministic replay produces identical effect logs
</success_criteria>

<output>
After completion, create `.planning/phases/01-execution-harness/01-01-SUMMARY.md`:

# Phase 1 Plan 1: Execution Harness Summary

**Standalone harness validates transactional ticks, deferred effects, and deterministic replay.**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ext` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase complete, ready for next phase
</output>
