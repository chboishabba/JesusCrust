---
phase: 06-browser-rollout
type: deployment
domain: integration
---

<objective>
Ship a guarded browser-side runtime (extension or shell) that deploys the drop-in adapter contract to real pages, gathers diagnostics, and proves a single measurable win without altering Phase-5 semantics.
Purpose: Validate the contract in the wild with real web workloads while keeping the invariant structure intact and surfaced.
Output: Prototype host shell (e.g., extension wiring), telemetry surface, and Phase-6 guardrails that make Phase-5 violations structurally impossible.<
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@docs/dropin_overview.md
@docs/dropin_adapter_contract.md
@prototypes/dropin/adapter.js
@prototypes/dropin/preact-renderer.js
@packages/js-host/src/runner.js
@prototypes/dropin/event-state-loop-test.js
@prototypes/dropin/virtualization-test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build a guarded browser host</name>
  <files>prototypes/browser-extension/host.js</files>
  <action>Sketch an extension/host prototype that injects the adapter into target pages, tracks tick boundaries, and exposes a fallback mechanism (per-origin disable) when invariant violations occur. The host must treat pages as untrusted, buffer DOM mutations, and commit deterministically once per tick. Use a feature flag to gate the transactional mode.</action>
  <verify>Host prototype runs on a demo page, logs commit counts, and disables itself after a fallback reason is recorded.</verify>
  <done>Extension host wire shown, fallback gating demonstrated, commits per tick enforced.</done>
</task>

<task type="auto">
  <name>Task 2: Ship telemetry + diagnostics</name>
  <files>prototypes/browser-extension/telemetry.js docs/dropin_adapter_contract.md</files>
  <action>Log commit durations, patch sizes, fallback/rollback reasons, and tick counts. Surface diagnostics through the adapter (host.getDiagnostics) and surface them in the extension UI/log, so fallback frequencies and reasons are visible. Document how to interpret the telemetry in the contract overview.</action>
  <verify>Telemetry logs show at least commit count, fallback reason, tick durations; docs explain how to read these metrics.</verify>
  <done>Telemetry pipeline captures key metrics and docs mention how to use them.</done>
</task>

<task type="auto">
  <name>Task 3: Define Phase-6 guardrails</name>
  <files>.planning/phases/06-browser-rollout/06-01-PLAN.md docs/dropin_adapter_contract.md</files>
  <action>Capture the guardrails locking Phase-5 semantics: (1) tokenized mutation contexts so only ticks mutate state; (2) runtime assertions preventing reads during mutation, enforcing microtask drain and commit count; (3) an immutable conformance suite (`npm test`) that always runs before merging, plus policy notes that any semantic change must document its impact. Mention these guardrails in the contract overview and plan.
  <verify>`docs/dropin_adapter_contract.md` references the guardrails and no new semantics are introduced by the extension host.
  <done>Guardrails explicitly written, referenced by docs, and enforced through the browser host implementation.
</task>

<task type="auto">
  <name>Task 4: Capture Phase-6 telemetry plan</name>
  <files>.planning/phases/06-browser-rollout/06-01-PLAN.md docs/phase6_browser_ui.md</files>
  <action>Document the telemetry requirements per tick, including script/style/layout/renderer durations, selectors/layout work proxies, patch size counters, and fallback metadata. Keep the plan lightweight but explicit so future instrumentation follows the same shape.</action>
  <verify>`docs/phase6_browser_ui.md` describes the telemetry schema, proxies, and why each metric exists.</verify>
  <done>Telemetry schema documented in `docs/phase6_browser_ui.md` (per-tick durations, selectors/layout proxies, aggregated surface guidance) so instrumentation can follow the same shape.</done>
</task>

<task type="auto">
  <name>Task 5: Outline Servo selector invalidation PR</name>
  <files>.planning/phases/06-browser-rollout/06-01-PLAN.md</files>
  <action>Produce a scoped PR outline for parallel selector invalidation planning that lives inside the commit boundary, lists telemetry & feature-flag requirements, defines safety valves/fallbacks, and clarifies what this PR will (and will not) touch.</action>
  <verify>Outline lays out scope/title/telemetry/safety and can be dropped directly into a Servo PR description.</verify>
  <done>Scope/telemetry/safety outline written in `docs/servo-selector-invalidation-pr.md` so Servo reviewers know exactly what to expect.</done>
</task>

<task type="auto">
  <name>Task 6: Publish a Phase-6 README</name>
  <files>docs/phase6_browser_ui.md</files>
  <action>Write a short README (or extend existing documentation) that summarizes the Phase-6 mission, lists locked guardrails, permitted changes, and the “measurement before optimization” workflow so future contributors stay disciplined.</action>
  <verify>README exists and clearly communicates the non-negotiable invariants plus the step-by-step approach to Phase-6 work.</verify>
  <done>`docs/phase6_README.md` captures the Phase-6 mission, locked invariants, permitted changes, and measurement-before-optimization workflow for future contributors.</done>
</task>

</tasks>

<servo_mapping>
| Phase-6 work | Servo subsystem | Notes |
|--------------|----------------|-------|
| Guarded browser host (extension) | Verso + servoshell/ports | host shell injects adapter, handles allowlist/fallback, flags. |
| Tokenized mutation channels + runtime barriers | Script + script_layout_interface | Enforces DOM ownership, prevents reads during ticks, reports fallback reasons. |
| Telemetry + diagnostics | Renderer / layout / resource manager | Capture commit durations, patch sizes, fallback reasons within existing telemetry hooks. |
| Virtualization/transactional execution | Constellation + renderer + layout threads | Reuses Queueing to ensure commits happen once per tick while layout + selector work stay parallelizable. |
| Parallelism “win” (selector, layout prep, decoding) | Layout/style/selectors + renderer | Serves as the first measurable win without altering JS semantics. |
</servo_mapping>

<parallelism_checklist>
1. Selector matching precompute (parallelizable by Servo) – ensure telemetry reports selector and invalidation durations separately.
2. Layout planning Bloom (back-end layout threads) – capture layout build time per tick + fallback triggers.
3. Resource decode (images, CSS) – measure decode queue length vs commit latency, keep processed data off main thread.
4. Renderer/compositor pacing – log scroll/input frame durations, show commit counts in telemetry.
5. Guardrail conformance – `npm run conformance` must pass before any Phase-6 change merges.
</parallelism_checklist>

<verification>
- [ ] Browser host prototype commits only once per real page tick
- [ ] Telemetry shows commit/fallback metrics for at least one page
- [ ] Guardrails documented and `npm test` still passes
- [ ] UI popup loads `ui.js` via a `<script type="module">` entry so diagnostics can use ES imports without classic-script errors
</verification>

<success_criteria>
- Real browser environment sees deterministic commits via the adapter
- Diagnostic surface explains fallback reasons and commit fingerprint counts
- Guardrails make Phase-5 invariants mechanically hard to break even in Phase 6 work
</success_criteria>

<output>
After this plan, consider adding a `.planning/phases/06-browser-rollout/06-01-SUMMARY.md` capturing the experiment learnings and any origin compatibility notes.
</output>

<architecture_section>
Phase-6 sits between Servo and Verso: Verso hosts the UI/allowlist/policy surface, Servo enforces the transactional tick contract, and SpiderMonkey continues to own JS semantics. The embedded Servo constellation schedules ticks, the Script layer enforces tokenized mutation channels and runtime barriers, and the layout/style/renderer pipeline consumes committed state while telemetry probes renderer/Layout/Resource stages. Parallelism is scoped to selector invalidation, layout planning, decoding, and renderer pacing, ensuring no JS reordering occurs outside the guarded commit boundary.
</architecture_section>

<pr_boundary_guidance>
Phase-6 work splits along two axes: policy/UI (Verso) versus semantics/parallelism (Servo). Contributions touching allowlists, telemetry display, or fallback thresholds belong in Verso; everything that mutates the guardrails (token API, barrier enforcements, PatchBatch semantics) resides near Servo or the adapter layer. No PR should merge without `npm run conformance` passing, and any change touching `prototypes/dropin/adapter.js`, `docs/dropin_adapter_contract.md`, or renderer shims must include a “semantic impact” note describing how Phase-5 invariants remain intact.
</pr_boundary_guidance>
