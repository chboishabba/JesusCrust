---
phase: 05-drop-in-acceleration
type: execute
domain: integration
---

<objective>
Integrate the drop-in adapter with a real renderer (Preact) to prove existing frameworks can drive deterministic commits.

Purpose: Show how an actual renderer lifecycle can emit PatchBatches through the adapter while preserving D0 invariants.
Output: Preact integration module, runnable example, and discovery doc notes describing the integration learnings.
</objective>

<execution_context>
~/.codex/skills/get-shit-done/workflows/execute-phase.md
~/.codex/skills/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-drop-in-acceleration/05-02-PLAN.md
@.planning/phases/05-drop-in-acceleration/05-02-SUMMARY.md
@.planning/phases/05-drop-in-acceleration/DISCOVERY.md
@docs/dropin_adapter_contract.md
@packages/js-host/src/runner.js
@prototypes/dropin/adapter.js
@prototypes/dropin/framework.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build a minimal Preact renderer</name>
  <files>prototypes/dropin/preact-renderer.js</files>
  <action>Implement a tiny Preact renderer that renders into `createDropInHost()` by using the virtual DOM API (h/render). The renderer should throttle to one commit per `render()` call, patch the adapter via `ensureNodeWithKey`, and wire event listeners through the adapterâ€™s `addEventListener`. Avoid hydration or hooks.</action>
  <verify>`node prototypes/dropin/preact-example.js` runs and logs serialization/fingerprint per tick.</verify>
  <done>Renderer translates Preact VNodes into adapter calls, with deterministic key mapping.</done>
</task>

<task type="auto">
  <name>Task 2: Create runnable Preact example</name>
  <files>prototypes/dropin/preact-example.js</files>
  <action>Write a script that mounts a simple Preact component tree (button, label) via `render()` into the adapter, triggers a state change to simulate two commits, logs serialized outputs/fingerprints, and asserts event handlers fire post-commit.</action>
  <verify>`node prototypes/dropin/preact-example.js` runs without errors and displays serialization/fingerprint twice plus event log.</verify>
  <done>Preact example demonstrates the adapter handling a real renderer while keeping D0 semantics.</done>
</task>

<task type="auto">
  <name>Task 3: Update research notes & contract references</name>
  <files>.planning/phases/05-drop-in-acceleration/DISCOVERY.md docs/dropin_adapter_contract.md</files>
  <action>Document the renderer integration, note any edge cases, and explicitly mention the invariant tests (microtask/mutation/identity/replay/rollback) now proving the adapter's readiness. Link to the prototype files from the contract doc.</action>
  <verify>DISCOVERY.md and the contract mention the Preact renderer and tests.</verify>
  <done>Research artifacts describe the realistic renderer integration and point to the new scripts.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `node prototypes/dropin/preact-example.js` passes
- [ ] `node prototypes/dropin/microtask-test.js` etc. still pass
</verification>

<success_criteria>

- Preact renderer routes VNodes through the adapter into deterministic patch batches
- Runnable example shows two commits with serialization/fingerprint and event callbacks
- Discovery/contract docs capture the integration lessons and reinforce invariants
</success_criteria>

<output>
After completion, create `.planning/phases/05-drop-in-acceleration/05-03-SUMMARY.md` describing the integration proof.
</output>
